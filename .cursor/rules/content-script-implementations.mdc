---
description: 
globs: 
alwaysApply: true
---
## General Process for Integrating a New AI Model/Service

This section outlines the typical workflow for adding support for a new AI model or service to the Cindra Summary extension, based on recent integrations like "Google Learning".

1.  **Create a New Content Script (`content_scripts/<service_name>_content.js`):**
    *   **Initialization:**
        *   Log script loading for debugging: `console.log('<ServiceName> content script loaded');`
        *   Implement an `isProcessing` boolean flag (default `false`) to prevent concurrent/duplicate operations.
    *   **Message Listener (`chrome.runtime.onMessage.addListener`):**
        *   Listen for messages from the background script, specifically for an `action === 'insertPrompt'`.
        *   If `isProcessing` is true, log and return early to avoid conflicts: `sendResponse({ success: false, error: 'Already processing' }); return true;`.
        *   Set `isProcessing = true` before starting the main logic.
        *   Call the main `insertPromptAndSubmit(message.prompt)` function.
        *   Handle success/failure responses using `sendResponse({ success: true/false, ... })`.
        *   Crucially, reset `isProcessing = false` in a `.finally()` block attached to the `insertPromptAndSubmit` promise chain to ensure the flag is cleared even if errors occur.
        *   Return `true` from the listener to indicate an asynchronous response is being handled.
    *   **DOM Interaction Utilities:**
        *   `waitForElement(selector, textContent = null, timeout = 10000)`:
            *   Asynchronously retries finding an element using `document.querySelector(selector)`.
            *   Optionally checks if `element.textContent.trim()` matches the provided `textContent` for more precise selection.
            *   Resolves with the found element or rejects with an error if not found within the `timeout` period.
        *   `insertTextInto<FieldType>(element, text)`: (e.g., `insertTextIntoTextarea`, `insertTextIntoEditableDiv`)
            *   Focuses the target `element` (`element.focus()`).
            *   Sets `element.value = text` (for textareas) or manipulates `innerHTML`/`innerText` for content-editable divs.
            *   Dispatches `new Event('input', { bubbles: true, composed: true })` and `new Event('change', { bubbles: true })` on the element to ensure the webpage's JavaScript listeners recognize the programmatic change.
        *   `robustClick(element)`:
            *   Ensures the `element` is scrolled into view: `element.scrollIntoView({ behavior: 'smooth', block: 'center' });` (optional, but good for elements that might be off-screen).
            *   Dispatches a sequence of mouse events: `mousedown`, `mouseup`, and `click` (`new MouseEvent(...)`) to simulate a more natural user click, which can be more reliable than a simple `.click()` for some complex UIs.
    *   **Core Logic (`async function insertPromptAndSubmit(prompt)`):**
        1.  Use `await waitForElement(...)` to locate the AI service's main text input field using a specific and robust CSS selector (e.g., by placeholder, class, ID).
        2.  Call `insertTextInto<FieldType>(inputField, prompt)` to populate the input field.
        3.  `await new Promise(resolve => setTimeout(resolve, 500-1000));` This delay allows the page UI to update (e.g., for a submit button to become enabled or visible after text input). The exact duration might need adjustment per target site.
        4.  Use `await waitForElement(...)` to find the service's submit button, again using specific selectors and often verifying its `textContent` (e.g., "Send", "Submit") for accuracy.
        5.  Call `robustClick(sendButton)` or a direct `sendButton.click()` to trigger the submission.
        6.  On successful submission (or in a `finally` block to ensure cleanup), clear relevant data from local storage using `chrome.storage.local.remove(['pending<ServiceName>Prompt', '<serviceName>PromptTimestamp'], () => { ... });` to prevent reprocessing.
    *   **Pending Prompt Handling (`function checkPendingPrompt()`):**
        1.  This function is typically called when the content script loads (e.g., on `DOMContentLoaded` or via `setTimeout(checkPendingPrompt, 250)` after page load to give elements time to render).
        2.  Checks `chrome.storage.local.get(['pending<ServiceName>Prompt', '<serviceName>PromptTimestamp'], (result) => { ... })`.
        3.  Validates that `result.pending<ServiceName>Prompt` exists and the `result.<serviceName>PromptTimestamp` is recent (e.g., `(Date.now() - timestamp) < 60000`) to avoid processing stale prompts.
        4.  **Crucially**: Removes the prompt from storage *before* attempting to submit it: `chrome.storage.local.remove(['pending<ServiceName>Prompt', '<serviceName>PromptTimestamp'], () => { /* then call insertPromptAndSubmit */ });`. This prevents re-submission if the page reloads or the script runs multiple times.
        5.  If a valid pending prompt is found, sets `isProcessing = true` (if not already) and calls `insertPromptAndSubmit(promptToProcess)`, ensuring `isProcessing` is reset in its `finally` block.

2.  **Update Manifest (`manifest.json`):**
    *   Add a new object to the `"content_scripts"` array:
        ```json
        {
          "matches": ["https://service.example.com/*"],
          "js": ["content_scripts/service_name_content.js"]
        }
        ```
    *   Ensure the service's domain (e.g., `"https://service.example.com/*"`) is added to `"host_permissions"` if not already covered by a broader pattern like `"*://*/*"`.

3.  **Update UI Files:**
    *   **Popup (`ui/popup/popup.html`):**
        *   Add an `<option>` to the `<select id="ai-model">` dropdown:
          `<option value="service-identifier">Service Name</option>`
          (The `value` should be a unique string, e.g., `"google-learning"`).
    *   **Options Page (`ui/options/options.html`):**
        *   Add a corresponding radio button for the AI model selection, ensuring the `value` attribute matches the one used in the popup:
          ```html
          <label class="radio-container">
            <input type="radio" name="ai-model" id="service-identifier" value="service-identifier">
            <span class="radio-label">Service Name</span>
          </label>
          ```
    *   **JavaScript for UI (`ui/popup/popup.js`, `ui/options/options.js`):**
        *   These scripts generally load the `aiModel` value from `chrome.storage.sync` (e.g., `google-ai-studio` by default) and populate the UI. If structured generically (reading the `value` from the selected HTML element), they might not require changes for new model additions beyond the HTML itself.

4.  **Update Background Script (`background/background.js`):**
    *   **Routing Logic (within `handleSummarize` which calls `sendToSelectedModel`):**
        *   In the `switch (model)` statement inside `sendToSelectedModel(model, prompt, content, title)`, add a new `case 'service-identifier':`
          `open<ServiceName>(prompt, content, title); break;`
    *   **Create `open<ServiceName>(prompt, content, title)` Function:**
        1.  Define `const targetUrl = 'https://service.example.com/';` (match the manifest URL, avoid trailing slashes if the content script match is specific).
        2.  **Prompt Formatting:**
            *   The `content` (scraped page data) is typically processed by `const cleanedContent = cleanupContentFormatting(content);`.
            *   The final prompt sent to the service is constructed by combining the user's custom `prompt` (from the UI), the `title` of the source page, and the `cleanedContent`. This combined payload is often wrapped in specific XML tags (e.g., `<Task>`, `<ContentTitle>`, `<Content>`) as required by the target AI service:
              ```javascript
              const combinedPrompt = `<Task>
${prompt}
</Task>

<ContentTitle>
${title || 'N/A'}
</ContentTitle>

<Content>
${cleanedContent}
</Content>`;
              ```
        3.  **Storage for Content Script:**
            *   Store the `combinedPrompt` (or `formattedPrompt`) and `Date.now()` as a timestamp in `chrome.storage.local` for the content script to pick up:
              `chrome.storage.local.set({ pending<ServiceName>Prompt: combinedPrompt, <serviceName>PromptTimestamp: Date.now() }, () => { ... });`
        4.  **Tab Management (inside the `chrome.storage.local.set` callback):**
            *   Query for existing tabs matching the service's URL: `chrome.tabs.query({ url: targetUrl + '*' }, (tabs) => { ... });` (using `targetUrl + '*'` for flexibility if sub-paths are involved).
            *   If `tabs.length > 0`, update the existing tab's URL to the base `targetUrl` (if necessary) and bring it into focus: `chrome.tabs.update(tabs[0].id, { active: true, url: targetUrl });`.
            *   Else (no existing tab), create a new tab: `chrome.tabs.create({ url: targetUrl });`.
            *   The content script, upon loading in this new or focused tab, will then execute its `checkPendingPrompt` logic to retrieve and inject the stored prompt. The background script does not directly message the content script after opening/focusing the tab in this pattern; it relies on the content script's load-time execution of `checkPendingPrompt`.

